/*
 * fotl check
 */
MACRO fotl_check (
"""
print(AALtoFOTL(self.aalprog))
"""
)


/*
 * Checking validity
 */
MACRO validate(c1 c2) (
"""
_c1 = self.clause(c1)
_c2 = self.clause(c2)
if _c1 is not None and _c2 is not None:
    validate(self, _c1, _c2, verbose=False)
"""
)


/*
 * Checking validity : verbose mode
 */
MACRO vvalidate(c1 c2) (
"""
_c1 = self.clause(c1)
_c2 = self.clause(c2)
if _c1 is not None and _c2 is not None:
    validate(self, _c1, _c2, verbose=True)
"""
)


/*
 * Checking validity and auto resolve conflicts
 */
MACRO resolve(c1 c2) (
"""
_c1 = self.clause(c1)
_c2 = self.clause(c2)
if _c1 is not None and _c2 is not None:
    validate(self, _c1, _c2, resolve=True)
"""
)


/*
 * Validate a single clause
 */
MACRO validate2(c1) (
"""
_c1 = self.clause(c1)
if _c1 is not None:
    validate2(self, _c1.to_ltl())
"""
)


/*
 * Checking satisfiability
 */
MACRO sat(c1) (
"""
_c1 = self.clause(c1)
if _c1 is not None:
    validate2(self, _c1.to_ltl(), True)
"""
)


/*
 * Show all loaded libs
 */
MACRO show_libs (
"""
print("loaded libs....")
for x in self.libs:
    print(x.file)
print("\n")
"""
)


/*
 * Translate clause c to FOTL
 */
MACRO fotl(c) (
"""
cl = self.clause(c)
if cl is not None:
    print(cl.to_ltl())
"""
)


/*
 * Print a clause
 */
MACRO show_clause(c) (
"""
cl = self.clause(c)
if cl is not None:
    print(cl)
"""
)


/*
 * Get natural language translation of a clause
 */
MACRO to_natural(c) (
"""
cl = self.clause(c)
if cl is not None:
    print(cl.to_natural())
"""
)


/*
 * Evaluate an FOTL expression
 */
MACRO do(a) (
"""
self.apply_check(code= AALtoFOTL(l) + " & " + a , verbose=False, show=True)["print"]
"""
)


/*
 * Disable agents declarations
 */
MACRO skip_defs() (
"""
def exitAgentDec(ctx):
    pass
self.exitAgentDec = exitAgentDec
"""
)


/*
 * Check usage consistency of two clauses
 */
MACRO validate_usage(c1 c2) (
"""
_c1 = self.clause(c1)
_c2 = self.clause(c2)

if _c1 is not None and _c2 is not None:
    pre_cond = build_env(self.aalprog)
    code = pre_cond + "\n%%  " + c1 + "\nclause(" + c1 + ").ue " + "\n & \n\n%%  " + c2 + "\nclause(" + c2 + ").ue"
    res = self.apply_check(code=code, show=False, verbose=True)
    if res["res"] == "Unsatisfiable":
        print(Color("{autored}  -> " + res["res"] + " : c1 & c2 are not consistent{/red}"))
    else:
        print(Color("{autogreen}  -> " + res["res"] + "{/green}"))
"""
)