\section{Getting started}

\subsection{Install AccLab}
\begin{itemize}
  \item To use the ltl prover, you need to put the following executable files (tspass, fotl-translate) in tools/your\_platform/ (linux/mac/win)
  \item Basic run : python aalc.py (you need python3.4.0 or greater)
  \item Run an AAL file : python aalc.py -i testfile.aal
\end{itemize}


%%%%%%%%%%
%% aalc
%%%%%%%%%%
\subsection{Using AAL compiler "aalc"}
{\lstset{style=shell}
\begin{lstlisting}[caption={aalc options}]
aalc 
  -h    --help                   display this help and exit
  -i    --input                  the input file
  -i    --output                 the output file
  -c    --compile                compile the file, that can be loaded after using -l
  -m    --monodic                apply monodic check on aal file
  -s    --shell                  run a shell after handling aal program
  -k    --check                  perform a verbose check
  -l    --load                   load a compiled aal file (.aalc) and run a shell
  -t    --fotl                   translate the aal program into FOTL
  -r    --reparse                reparse tspass file
  -r    --recompile              recompile the external files
  -b    --no-colors              disable colors in output
  -x    --compile-stdlib         compile the standard library
  -d    --hotswap                enable hotswaping (for development only)
  -a    --ast                    show ast tree
  -u    --gui                    run the gui (BETA)
\end{lstlisting}
}

%%%%%%%%%%%%%%%%%%
%% first aal prog
%%%%%%%%%%%%%%%%%%
\subsection{Writing your first AAL program}
Let consider the following senario, we have three actors :
\begin{itemize}
    \item cloud storage service : let call it \texttt{css} which is a cloud service provider
    \item alice and bob : an end users that uses css service
\end{itemize}

The \texttt{css} offers the following services : read (a user reads some data form css server),
store (a user stores some data into css server), delete (a user deletes some data from css server).
\texttt{css} allows users to read/store/delete only their data on his server, and don't allow them to read other
customers data. \texttt{css} can also read and delete any data from his server.

Alice want to check if \texttt{css} policy respect her privacy. Typically she want to know if she is allowed to
performs some actions and if bob can read here data.


\begin{enumerate}[a.]

    \item \textbf{Declaring services}
The services are the
\begin{lstlisting}
SERVICE read
SERVICE store
SERVICE delete
\end{lstlisting}

    \item \textbf{Declaring actors} : first we need to declare our actors
\begin{lstlisting}
// Agents declaration
AGENT alice
AGENT bob
AGENT css
\end{lstlisting}

    \item \textbf{Linking services and actors}
First we need to declare our actors
\begin{lstlisting}
AGENT alice TYPES() REQUIRED(read store delete) PROVIDED()
AGENT bob   TYPES() REQUIRED(read store delete) PROVIDED()
AGENT css   TYPES() REQUIRED() PROVIDED(read store delete)
\end{lstlisting}


    \item \textbf{Defining policies}
First we need to declare our actors
\begin{lstlisting}
/*
 * Cloud storage service provider policy
 */
CLAUSE css_policy (
    FORALL d:data FORALL a:Actor

    // Allow users to read their data
    IF (d.subject == a) THEN {
        PERMIT a.read[css](d)
    } AND

    // Deny access to read other
    IF (d.subject != a) THEN {
        DENY a.read[css](d)
    } AND

    // Allow css to read/delete stored data
    PERMIT css.read[css](d) AND
    PERMIT css.delete[css](d)
)

/*
 * Alice's preferences
 */
CLAUSE alice_policy (
    FORALL d:data
    // Alice want to be able to read all her data stored on css
    IF (d.subject == alice) THEN {
        PERMIT alice.read[css](d)
    }
)
\end{lstlisting}

    \item \textbf{Writing checks}
Now we want to check if \texttt{Alice}'s privacy preferences are respected by the \texttt{css} policy.
To do this, we can call the macro \texttt{validate} and passing the the clauses names as arguments.
Important : Note that the order of arguments is important.
\begin{lstlisting}
CALL validate("css_policy" "alice_pref")
\end{lstlisting}

\end{enumerate}


\subsection{Running the program}

\begin{itemize}
	\item Run the AAL program
{\lstset{style=shell}
\begin{lstlisting}
root@root/:$ python aalc -i examples/tuto0.aal

------------------------- Monodic check -------------------------
Monodic check passed !
------------------------- Starting Validity check -------------------------
c1 : css_policy
c2 : alice_pref
----- Checking c1 & c2 consistency :
  -> Satisfiable
----- Checking c1 => c2 :
  -> Satisfiable
----- Checking ~(c1 => c2) :
  -> Unsatisfiable

[VALIDITY] Formula is valid !
------------------------- Validity check End -------------------------

File : examples/tuto0.aal

Execution time : 0.24277639389038086
\end{lstlisting}

Here the result of

	\item Perform an detailed check
\begin{lstlisting}
root@root/:$ python aalc -i examples/tuto0.aal -k

------------------------- Start Checking -------------------------

** DECLARATIONS
[DECLARED AGENTS]   : 3
[DECLARED SERVICES] : 6
[DECLARED DATA]     : 0
[DECLARED TYPES]    : 10

*** Forwards references check
[AGENTS]   : 0
[SERVICES] : 0
[DATA]     : 0
[TYPES]    : 0

** LOADED libraries
[LIBS] : 2

** CLAUSES
[CLAUSES] : 2
Monodic test :
|css_policy | Formula is monodic ! |
|alice_pref | Formula is monodic ! |
-------------------------- Checking End -------------------------
\end{lstlisting}


	\item Perform monodic test on all clauses :
\begin{lstlisting}
root@root/:$ python aalc -i examples/tuto0.aal -m

------------------------- Start Checking -------------------------
|css_policy | Formula is monodic ! |
|alice_pref | Formula is monodic ! |
-------------------------- Checking End -------------------------
\end{lstlisting}


	\item Translate AAL program into FOTL (in tspass syntax):
\begin{lstlisting}
root@root/:$ python aalc -i examples/tuto0.aal -t

------------------------- FOTL Translation start -------------------------

%%%%%%%%% START EVN %%%%%%%%%%%
%%% Types knowledge
data(CTS)  &
Actor(CTS)  &
DataSubject(CTS)  &
DataController(CTS)  &
DataProcessor(CTS)  &
DwDataController(CTS)  &
Auditor(CTS)  &
CloudProvider(CTS)  &
CloudCustomer(CTS)  &
EndUser(CTS)  &


%%% Action authorizations
(![x, y, z] (read(x, y, z) => Pread(x, y, z))) &
(![x, y, z] (store(x, y, z) => Pstore(x, y, z))) &
(![x, y, z] (delete(x, y, z) => Pdelete(x, y, z))) &
(![x, y, z] (read(x, y, z) => Pread(x, y, z))) &
(![x, y, z] (write(x, y, z) => Pwrite(x, y, z))) &
(![x, y, z] (audit(x, y, z) => Paudit(x, y, z))) &


%%% Actors knowledge
Actor(alice)  &
Actor(bob)  &
Actor(css)  &

%%%%%%%%% END EVN %%%%%%%%%%%

%% Clause : css_policy
always(![d] ( data(d) & (![a] ( Actor(a) & (((( (subject(d, a) => Pread(a, css, d)) &
(~subject(d, a) => ~Pread(a, css, d))) & Pread(css, css, d)) & Pdelete(css, css, d)))))) )
%% Clause : alice_pref
always(![d] ( data(d) & ( (subject(d, alice) => Pread(alice, css, d)))) )


-------------------------- FOTL Translation end --------------------------
\end{lstlisting}
}
\end{itemize}





%%%%%%%%%%%%%%%%%%
%% Core libs
%%%%%%%%%%%%%%%%%%
\subsection{Using core libraries}
You can load external AAL files using \texttt{LOAD "aal\_file"}(without the extension) 

\paragraph{core.types} Contains the basic types declarations (Actor, DataSubject, DataController, DataProcessor, ...)
\begin{lstlisting}
LOAD "core.types"
\end{lstlisting}


\paragraph{core.macros} Contains some useful macros.
\begin{lstlisting}
// Loading lib
LOAD "core.macros"


\end{lstlisting}




%%%%%%%%%%%%%%%%%%
%% Advenced checks
%%%%%%%%%%%%%%%%%%
\subsection{Advanced checks}
dzd



%%%%%%%%%%%%%%%%%%
%% Using shell
%%%%%%%%%%%%%%%%%%
\subsection{Using the shell}
The shell is a useful tool for developing 


{
\lstset{style=shell}

\begin{itemize}
	\item Run the shell.
\begin{lstlisting}
aalc -i examples/tuto1.aal -s

/* Result : 
shell >

*/
\end{lstlisting}

  \item Type help to show the shell help.
\begin{lstlisting}
  Shell Help
 - call(macro, args)   call a macro where /
         *macro : is the name of the macro
         *args : a list of string; << ex : ["'args1'", "'args2'", ..."'argsN'"] >>
 - clauses()           show all declared clauses in the loaded aal program
 - macros()            show all declared macros in the loaded aal program
 - quit / q            exit the shell
 - help / h / man()    show this help
 - self                the current compiler instance of the loaded aal program
 - aalprog             the current loaded aal program 
 - man(arg)            print the help for the given arg
 - hs(module)          hotswaping : reload the module
 - r()                 hot-swaping the shell
\end{lstlisting}

  \item Here an example, we print all clauses in the AAL program.
\begin{lstlisting}
shell> clauses()

/* Result :
kim_policy cloudX_policy 

*/
\end{lstlisting}

  \item self variable represent the co
\begin{lstlisting}
shell> self

/* Result :
<AALCompiler.AALCompilerListener object at 0x7f8b00ce8630>

*/

shell> man(self)

/* Result :
printing manual for <class 'AALCompiler.AALCompilerListener'>
Manual for aal compiler visitor
 - Attributes
   -  aalprog      Get the AAL program instance
   -  file         The AAL source file
   -  libs         Show the loaded libraries
   -  libsPath     Print the standard lib path
 - Methods
   - load_lib(lib_name)    Load an aal file
   - clause(clauseId)      Get a clause
   - show_clauses()        Print all clauses
   - get_clauses()         Get all clauses (array format)
   - get_macros()          Get all macros

*/

shell> man(aalprog)

/* Result :
printing manual for <class 'AALMetaModel.m_aalprog'>

    AAL program class.
    Note that clauses and macros extends a declarable type, but are not in the declarations dict

    Attributes
        - clauses: a list that contains all program clauses
        - declarations: a dictionary that contains lists of typed declarations
        - comments: a list that contains program's comment
        - macros: a list that contains program's macros declarations
        - macroCalls: a list that contains program's comment

*/
\end{lstlisting}

  \item hotswaping commands are used for debugging purpose only.
  r() command allows you to reload the shell after 

  hs(module) reloading other modules after 
  ! IMORTANT : to use hotswaping properly you must enable it explicitly in aalc arguments
  \texttt{-d / --hotswap},

\end{itemize}

}